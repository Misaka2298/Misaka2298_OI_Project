void manacher(char *t) // 函数 manacher，参数 t 为处理后的字符数组（通常包含分隔符以统一奇偶回文）
{
    int r = 0, c = 0; // r：当前已知回文的最右边界（下一个不可达位置），c：对应的回文中心位置

    for (int i = 0; i < n; i++) // 遍历处理后字符串的每个位置 i（n 为处理后字符串的长度）
    {
        if (i < r)
            p[i] = min(p[c * 2 - i], r - i); // 若 i 在当前右边界内，初始半径取对称点的半径或到右边界的距离的较小者
        else
            p[i] = 1; // 否则从半径 1 开始（至少包含自身）

        while (t[i - p[i]] == t[i + p[i]])
            p[i]++; // 尝试向两边扩展回文半径，直到左右字符不等为止 
        if (i + p[i] > r)
        { // 若以 i 为中心的回文超出了当前右边界
            r = i + p[i]; // 更新右边界为新回文的右端（下一个不可达位置）
            c = i;        // 更新中心为当前 i
        }

    }
}